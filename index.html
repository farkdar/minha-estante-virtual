<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Estante Virtual</title>
  <style>
    /* ======================================================
   CARREGAR ESQUELETO
   ‚Äî Anima√ß√£o ‚Äúpulse‚Äù para estado de carregamento
   ‚Äî .skeleton: estilo base para elementos placeholder
   ‚Äî .book.skeleton: mant√©m propor√ß√£o e visibilidade do esqueleto
   ====================================================== */

    @keyframes pulse {
      0% {
        background: #ddd;
      }

      50% {
        background: #ccc;
      }

      100% {
        background: #ddd;
      }
    }

    .skeleton {
      background: #ddd;
      animation: pulse 1.5s infinite;
      border-radius: 4px;
    }

    .book.skeleton {
      aspect-ratio: 5 / 7;
      /* mant√©m propor√ß√£o de capa de livro */
      opacity: 1 !important;
      /* garante visibilidade */
      transform: none !important;
    }


    /* ======================================================
   ESTRUTURA DA √ÅRVORE DE FILTROS
   ‚Äî .tree: container principal de filtros
   ‚Äî .tree-toggle: alvos clic√°veis para expandir/contrair
   ‚Äî .toggle-icon: √≠cone de seta alinhado √† direita
   ====================================================== */

    .tree {
      display: block;
    }

    .tree>ul {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: none;
      overflow: visible;
    }

    .tree ul ul {
      padding-left: 10px;
      /* recuo para sublistas */
      max-height: 0;
      /* oculto por padr√£o */
      overflow: hidden;
      transition: max-height 0.4s ease-out;
    }

    .tree li {
      position: relative;
    }

    .tree-toggle {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-toggle.active-filter {
      background-color: rgba(255, 255, 255, 0.1);
      outline: 2px solid #6f4e37;
      /* destaque de filtro ativo */
    }

    .tree li.open>ul {
      max-height: 1000px;
      /* expande lista */
      transition: max-height 0.4s ease-in;
    }

    .toggle-icon {
      font-weight: bold;
      width: 1em;
      text-align: center;
      cursor: pointer;
      margin-left: auto;
      /* empurra para o fim */
      margin-right: 0;
    }


    /* ======================================================
   LAYOUT & SIDEBAR
   ‚Äî body: layout flex com sidebar fixa
   ‚Äî .sidebar: painel lateral de filtros fora da tela
   ‚Äî .sidebar.show / .sidebar-hidden: mostra/esconde
   ‚Äî .sidebar-header & .close-btn: cabe√ßalho da sidebar
   ‚Äî .main / .main.shifted: √°rea principal e estado deslocado
   ====================================================== */

    body {
      margin: 0;
      font-family: 'Georgia', serif;
      background: #f4efe9;
      display: flex;
      /* sidebar + conte√∫do */
    }

    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 260px;
      max-height: 100vh;
      background-color: rgba(62, 47, 28, 0.9);
      color: #fff;
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.4);
      padding: 20px;
      z-index: 1500;
      overflow-y: auto;
      transform: translateX(-100%);
      /* escondida √† esquerda */
      transition: transform 0.3s ease-in-out;
    }

    .sidebar.show {
      transform: translateX(0);
      /* mostra sidebar */
    }

    .sidebar.sidebar-hidden {
      transform: translateX(-100%);
      /* mant√©m escondida */
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .close-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .main {
      flex: 1;
      padding: 30px;
      transition: margin 0.3s ease;
    }

    .main.shifted {
      margin-left: 260px;
      /* desloca ao abrir sidebar */
    }


    /* ======================================================
   BUSCA
   ‚Äî .search-container: wrapper flex
   ‚Äî #searchInput: input alinhado √† direita
   ====================================================== */

    .search-container {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 20px;
    }

    #searchInput {
      width: 200px;
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 6px;
      margin-left: auto;
      /* empurra para a direita */
    }


    /* ======================================================
   ESTANTE
   ‚Äî .shelf: container flex para livros
   ‚Äî .book: cart√£o individual com transi√ß√µes
   ‚Äî .book.showing: estado vis√≠vel
   ‚Äî Breakpoints para celulares
   ====================================================== */

    .shelf {
      display: flex;
      flex-wrap: wrap;
      gap: 25px;
      justify-content: center;
    }

    .book {
      width: calc(10% - 25px);
      min-width: 100px;
      text-align: center;
      font-size: 14px;
      color: #333;
      opacity: 0;
      /* oculto at√© aparecer */
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
    }

    .book.showing {
      opacity: 1;
      transform: none;
    }

    @media (max-width: 600px) {
      .book {
        width: calc(25% - 25px);
      }

      .shelf {
        gap: 16px;
      }
    }

    @media (max-width: 400px) {
      .book {
        width: calc(50% - 25px);
      }
    }


    /* ======================================================
   FLIP CARD
   ‚Äî .flip-card: cont√™iner com perspectiva 3D
   ‚Äî .flip-inner: contexto 3D e rota√ß√£o
   ‚Äî .flip-front / .flip-back: faces escondidas
   ‚Äî .hidden: oculta itens filtrados
   ====================================================== */

    .flip-card {
      width: 100%;
      aspect-ratio: 5 / 7;
      perspective: 1000px;
    }

    .hidden {
      display: none !important;
    }

    .flip-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    @media (hover: hover) {
      .flip-card:hover .flip-inner {
        transform: rotateY(180deg);
        /* rota√ß√£o ao passar o mouse */
      }
    }

    .flip-card.flipped .flip-inner {
      transform: rotateY(180deg);
      /* rota√ß√£o por classe .flipped */
    }

    .flip-front,
    .flip-back {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 4px;
      backface-visibility: hidden;
      box-shadow: 3px 6px 10px rgba(0, 0, 0, 0.4);
    }

    .flip-front {
      overflow: hidden;
    }

    .flip-front img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .no-cover {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      background: #d9cfc3;
      padding: 6px;
    }

    .flip-back {
      background: #fff;
      color: #333;
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 8px;
      gap: 8px;
      text-align: center;
    }

    .book-title {
      font-size: 12px;
      font-weight: bold;
    }

    .read-button {
      font-size: 12px;
      padding: 4px 8px;
      background-color: #6f4e37;
      color: #fff;
      border: none;
      border-radius: 4px;
      text-decoration: none;
    }


    /* ======================================================
   UTILIT√ÅRIO & BOT√ÉO DE TOGGLE
   ‚Äî .toggle-button: bot√£o fixo para abrir filtros
   ====================================================== */

    .toggle-button {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: #6f4e37;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 2000;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <!-- Painel lateral de filtros, inicialmente oculto -->
  <div class="sidebar sidebar-hidden" id="sidebar">
    <!-- Cabe√ßalho da sidebar com t√≠tulo e bot√£o de fechar -->
    <div class="sidebar-header">
      <h2>üìö Filtros</h2> <!-- T√≠tulo da se√ß√£o de filtros -->
      <button id="closeSidebar" class="close-btn">√ó</button> <!-- Bot√£o para fechar a sidebar -->
    </div>

    <!-- Container da √°rvore de filtros (itens din√¢micos inseridos via JavaScript) -->
    <div class="tree" id="filterTree"></div>
  </div>

  <!-- Bot√£o fixo para abrir/fechar a sidebar de filtros -->
  <button id="toggleSidebar" class="toggle-button">üìÅ Filtros</button>

  <!-- √Årea principal de conte√∫do -->
  <div class="main">
    <!-- Wrapper flex para o campo de busca -->
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Buscar livro por nome‚Ä¶">
      <!-- Input para digitar o termo de busca -->
    </div>

    <!-- Container flex√≠vel que exibir√° as capas dos livros -->
    <div class="shelf" id="shelf"></div>
  </div>


  <script>
    // ===== Fun√ß√£o debounce =====
    // Atrasar a execu√ß√£o da fun√ß√£o fn at√© que o usu√°rio pare de disparar eventos por 'delay' ms
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);                     // Limpa qualquer timeout pendente
        timeout = setTimeout(() => fn.apply(this, args), delay);  // Agenda nova chamada
      };
    }

    // ===== Gera URL de dados para capa =====
    // Cria dinamicamente uma imagem de capa (PNG) usando canvas e retorna como DataURL
    function generateCoverDataUrl(title, width = 400, height = 600) {
      // Cria elemento canvas e define largura/altura
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");

      // Cria gradiente vertical de cor para fundo da capa
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, "#6f4e37");
      grad.addColorStop(1, "#d9cfc3");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);            // Preenche fundo

      // Configura estilo de texto para o t√≠tulo
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      let fontSize = 40;
      ctx.font = `${fontSize}px serif`;

      // Ajusta fonte para caber na largura, reduzindo at√© encaixar
      while (ctx.measureText(title).width > width - 40) {
        fontSize -= 2;
        ctx.font = `${fontSize}px serif`;
      }

      // Desenha o texto centralizado
      ctx.fillText(title, width / 2, height / 2);

      // Retorna DataURL em PNG
      return canvas.toDataURL("image/png");
    }

    // ===== Configura√ß√µes do Google Drive =====
    const folderId = "10A__4JOje3uuOc4-ywuwikswsgPiQf4R";  // ID da pasta de capas
    const apiKey = "AIzaSyCSfROD8xDz5GvmvcRIt5X1FqIWk2Yb7xc";     // Chave de API
    const capaFolderName = "capas";                              // Nome da subpasta de capas
    let capasDrive = {};                                          // Cache de metadados das capas

    // ===== Remove extens√£o de arquivo =====
    function stripExtension(name) {
      return name.replace(/\.[^/.]+$/, "");  // Remove tudo ap√≥s o √∫ltimo ponto
    }

    // ===== Constr√≥i objeto de √°rvore a partir de paths =====
    function buildTree(paths) {
      const tree = {};
      paths.forEach(path => {
        const parts = path.split("/").filter(Boolean);  // Divide por '/' e remove vazios
        let current = tree;
        parts.forEach(part => {
          if (!current[part]) current[part] = {};        // Cria n√≥ se n√£o existir
          current = current[part];                       // Desce um n√≠vel
        });
      });
      return tree;
    }

    // ===== Cria elementos HTML para √°rvore de filtros =====
    function createTreeElement(tree, parentPath = "") {
      const ul = document.createElement("ul");

      // Ordena alfabeticamente considerando pt-BR
      Object.keys(tree)
        .sort((a, b) => a.localeCompare(b, 'pt-BR'))
        .forEach(key => {
          const li = document.createElement("li");
          li.classList.add("tree-node");

          const span = document.createElement("span");
          span.textContent = key;
          span.className = "tree-toggle";

          const fullPath = parentPath ? `${parentPath}/${key}` : key;
          const hasChildren = Object.keys(tree[key]).length > 0;
          let toggleIcon = null;

          if (hasChildren) {
            // Marca n√≥ com filhos e adiciona √≠cone
            span.classList.add("has-children");
            toggleIcon = document.createElement("span");
            toggleIcon.className = "toggle-icon";
            toggleIcon.textContent = "+";         // √≠cone para expandir
            span.appendChild(toggleIcon);
          }

          // Evento de clique no filtro
          span.onclick = e => {
            e.stopPropagation();                    // Evita borbulhar para outros √≠tems

            if (hasChildren) {
              // Fecha outros n√≥s abertos
              Array.from(li.parentElement.children)
                .filter(el => el.classList.contains('open'))
                .forEach(sib => {
                  if (sib !== li) {
                    sib.classList.remove("open");
                    const icon = sib.querySelector(".toggle-icon");
                    if (icon) icon.textContent = "+";
                  }
                });

              // Alterna estado do n√≥ atual
              li.classList.toggle("open");
              toggleIcon.textContent = li.classList.contains("open") ? "‚Äì" : "+";
            }

            // Aplica filtro de livros baseado no caminho completo
            filterBooks(fullPath);

            // Atualiza classe active-filter
            document.querySelectorAll(".tree-toggle.active-filter")
              .forEach(s => s.classList.remove("active-filter"));
            span.classList.add("active-filter");
          };

          li.appendChild(span);

          if (hasChildren) {
            // Chamada recursiva para filhos
            const subTree = createTreeElement(tree[key], fullPath);
            li.appendChild(subTree);
          }

          ul.appendChild(li);
        });

      return ul;
    }

    // ===== Filtra livros pelo caminho de categoria =====
    function filterBooks(categoryPath) {
      // Percorre todos os elementos .book que possuem data-path
      document.querySelectorAll('.book[data-path]').forEach(book => {
        const bookPath = book.dataset.path.toLowerCase();          // Caminho do livro (minusculas)
        const category = categoryPath.toLowerCase();               // Categoria selecionada (minusculas)

        // Verifica se o livro pertence exatamente √† categoria ou a um subdiret√≥rio
        const isMatch = bookPath === category || bookPath.startsWith(category + "/");

        // Adiciona ou remove a classe 'hidden' conforme correspond√™ncia
        book.classList.toggle("hidden", !isMatch);
      });

      // Remove destaque de filtro ativo em todos os spans
      document.querySelectorAll('.tree span').forEach(span => span.classList.remove("active-filter"));

      // Marca o span correspondente √† categoria atual como ativo
      document.querySelectorAll('.tree span').forEach(span => {
        if (span.textContent === categoryPath.split("/").pop()) {
          span.classList.add("active-filter");
        }
      });
    }

    // ===== Exibe skeletons enquanto os dados carregam =====
    function showSkeletons(count = 8) {
      const shelf = document.getElementById('shelf');
      shelf.innerHTML = '';                         // Limpa conte√∫do anterior
      for (let i = 0; i < count; i++) {
        const sk = document.createElement('div');
        sk.className = 'book skeleton';             // Aplica estilo de placeholder
        shelf.appendChild(sk);
      }
    }

    // ===== Busca ID de pasta pelo nome (Google Drive) =====
    async function getFolderIdByName(parentId, folderName) {
      const url =
        `https://www.googleapis.com/drive/v3/files?` +
        `q='${parentId}'+in+parents+and+trashed=false+and+mimeType='application/vnd.google-apps.folder'` +
        `&key=${apiKey}&fields=files(id,name)`;
      const res = await fetch(url);
      const data = await res.json();

      // Encontra a pasta que bate com o nome (case-insensitive)
      const folder = data.files.find(f => f.name.toLowerCase() === folderName.toLowerCase());
      return folder ? folder.id : null;
    }

    // ===== Lista recursivamente todas as capas dentro de uma pasta =====
    async function listCapasRecursively(parentId) {
      const url =
        `https://www.googleapis.com/drive/v3/files?` +
        `q='${parentId}'+in+parents+and+trashed=false` +
        `&key=${apiKey}&fields=files(id,name,mimeType)`;
      const res = await fetch(url);
      const data = await res.json();
      let result = {};

      for (const file of data.files) {
        if (file.mimeType === "application/vnd.google-apps.folder") {
          // Se for pasta, chama recursivamente
          const subResults = await listCapasRecursively(file.id);
          Object.assign(result, subResults);
        } else {
          // Adiciona URL da imagem da capa no resultado
          const name = stripExtension(file.name).toLowerCase();
          result[name] = `https://lh3.googleusercontent.com/d/${file.id}=w400-h600`;
        }
      }
      return result;
    }

    // ===== Lista recursivamente todos os arquivos de texto =====
    async function listFilesRecursively(parentId, path = "") {
      const url =
        `https://www.googleapis.com/drive/v3/files` +
        `?q='${parentId}'+in+parents+and+trashed=false` +
        `&key=${apiKey}` +
        `&fields=files(id,name,mimeType,webViewLink,thumbnailLink)`;
      const res = await fetch(url);
      const data = await res.json();
      let results = [];

      for (const file of data.files || []) {
        if (file.mimeType === "application/vnd.google-apps.folder") {
          // Ignora subpasta de capas e percorre outras pastas
          if (file.name.toLowerCase() === capaFolderName) continue;
          const sub = await listFilesRecursively(file.id, path + file.name + "/");
          results = results.concat(sub);
        } else {
          // Anexa caminho relativo e adiciona √† lista
          file.path = path;
          results.push(file);
        }
      }
      return results;
    }

    // ===== Renderiza os livros na estante =====
    async function renderBooks(defaultRoot = 'Livros') {
      const shelf = document.getElementById('shelf');
      const treeRoot = document.getElementById('filterTree');
      showSkeletons();                              // 1) mostra placeholders
      treeRoot.innerHTML = '';                       // limpa √°rvore antiga

      try {
        // ===== 1) Carregamento e cache =====
        let files;
        const cache = sessionStorage.getItem('estanteCache');
        if (cache) {
          const parsed = JSON.parse(cache);
          const cacheValidoPorMs = 4 * 60 * 60 * 1000; // 4h em ms
          const expirado = Date.now() - parsed.timestamp > cacheValidoPorMs;

          if (!expirado) {
            // Usa cache v√°lido: arquivos e capas j√° armazenados
            files = parsed.files.sort((a, b) =>
              a.name.localeCompare(b.name, 'pt-BR', { sensitivity: 'base' })
            );
            capasDrive = parsed.capas;
          } else {
            sessionStorage.removeItem('estanteCache');
          }
        }

        if (!files) {
          // Busca pastas e arquivos no Drive
          const capaFolderId = await getFolderIdByName(folderId, capaFolderName);
          if (capaFolderId) {
            capasDrive = await listCapasRecursively(capaFolderId);
          }
          files = await listFilesRecursively(folderId);
          files.sort((a, b) => a.name.localeCompare(b.name, 'pt-BR', { sensitivity: 'base' }));

          // Salva no sessionStorage
          sessionStorage.setItem(
            'estanteCache',
            JSON.stringify({ files, capas: capasDrive, timestamp: Date.now() })
          );
        }

        // ===== 2) Cria√ß√£o dos cards =====
        shelf.innerHTML = '';
        const allPaths = [];
        for (const file of files) {
          const name = stripExtension(file.name);
          const nameNorm = name.toLowerCase();
          const path = file.path.replace(/\/$/, '');
          allPaths.push(path);

          // Escolhe URL de capa: manual, thumbnail ou gerada
          const manualCover = capasDrive[nameNorm];
          const thumbCover = file.thumbnailLink;
          const coverUrl = manualCover || thumbCover || generateCoverDataUrl(name);

          // Monta estrutura HTML do card
          const bookDiv = document.createElement('div'); bookDiv.className = 'book';
          bookDiv.dataset.path = path;

          const flipCard = document.createElement('div'); flipCard.className = 'flip-card';
          const flipInner = document.createElement('div'); flipInner.className = 'flip-inner';

          // Face frontal com imagem
          const front = document.createElement('div'); front.className = 'flip-front';
          const img = document.createElement('img');
          img.loading = 'lazy'; img.src = coverUrl; img.alt = name;
          front.appendChild(img);

          // Face traseira com t√≠tulo e bot√£o de leitura
          const back = document.createElement('div'); back.className = 'flip-back';
          const bookTitle = document.createElement('div'); bookTitle.className = 'book-title';
          bookTitle.textContent = name;
          const readButton = document.createElement('a'); readButton.className = 'read-button';
          readButton.href = file.webViewLink; readButton.target = '_blank';
          readButton.textContent = 'Ler';
          back.append(bookTitle, readButton);

          flipInner.append(front, back);
          flipCard.appendChild(flipInner);
          bookDiv.appendChild(flipCard);
          shelf.appendChild(bookDiv);

          // Anima√ß√£o de entrada
          requestAnimationFrame(() => bookDiv.classList.add('showing'));
        }

        // ===== 3) Monta √°rvore de filtros =====
        const treeData = buildTree(allPaths);
        const treeStructure = createTreeElement(treeData);
        const wrapperUl = document.createElement('ul');
        const wrapperLi = document.createElement('li');
        wrapperLi.classList.add('open');
        wrapperLi.appendChild(treeStructure);
        wrapperUl.appendChild(wrapperLi);
        treeRoot.appendChild(wrapperUl);

        // ===== 4) Aplica filtro inicial =====
        filterBooks(defaultRoot);

      } catch (err) {
        console.error("Erro ao carregar estante:", err);
        shelf.innerHTML = "<p>Erro ao carregar arquivos.</p>";  // Mensagem de erro para o usu√°rio
      }
    }

    // ===== Intera√ß√µes ap√≥s carregamento da p√°gina =====
    document.addEventListener("DOMContentLoaded", () => {
      renderBooks('Livros');                          // Carrega a estante quando o DOM estiver pronto

      const shelf = document.getElementById('shelf');
      const toggleBtn = document.getElementById("toggleSidebar");   // Bot√£o para abrir a sidebar
      const sidebar = document.getElementById("sidebar");         // Painel lateral de filtros
      const closeBtn = document.getElementById("closeSidebar");    // Bot√£o '√ó' para fechar a sidebar
      const filterTree = document.getElementById("filterTree");      // Elemento raiz da √°rvore de filtros

      // ‚Äî‚Äî‚Äî Flip √∫nico por vez em mobile ‚Äî‚Äî‚Äî
      shelf.addEventListener('click', e => {
        const card = e.target.closest('.flip-card');
        if (!card) return;                         // s√≥ continua em cima de .flip-card
        if (e.target.closest('.read-button')) return; // ignora clique no ‚ÄúLer‚Äù

        // em telas ‚â§600px, desvira todos os outros antes de virar este
        if (window.innerWidth <= 600) {
          document.querySelectorAll('.flip-card.flipped')
            .forEach(c => { if (c !== card) c.classList.remove('flipped'); });
        }

        // executa o flip neste card
        card.classList.toggle('flipped');
      });

      // ‚Äî‚Äî‚Äî Fecha todos os flips ao clicar fora de qualquer card ‚Äî‚Äî‚Äî
      document.addEventListener('click', e => {
        if (e.target.closest('.flip-card') || e.target.closest('.read-button')) return;
        document.querySelectorAll('.flip-card.flipped')
          .forEach(c => c.classList.remove('flipped'));
      });

      // Fecha a sidebar ao clicar fora dela ou do bot√£o de toggle
      document.addEventListener("click", (event) => {
        const clickDentro = sidebar.contains(event.target);          // Clique dentro da sidebar?
        const clickToggle = toggleBtn.contains(event.target);        // Clique no bot√£o de abrir?

        if (!clickDentro && !clickToggle && sidebar.classList.contains("show")) {
          // Remove a classe que exibe a sidebar
          sidebar.classList.remove("show");
          sidebar.classList.add("sidebar-hidden");
          toggleBtn.style.display = "block";                        // Reexibe o bot√£o de abrir

          // Mant√©m apenas o n√≥ raiz da √°rvore sempre aberto
          const rootLi = filterTree.querySelector(":scope > ul > li");
          filterTree.querySelectorAll("li.open").forEach(li => {
            if (li !== rootLi) {
              li.classList.remove("open");                          // Fecha subn√≥s abertos
              const icon = li.querySelector(".toggle-icon");
              if (icon) icon.textContent = "+";                     // Restaura √≠cone de '+'
            }
          });
        }
      });

      // Abre a sidebar ao clicar no bot√£o de toggle
      toggleBtn.addEventListener("click", () => {
        sidebar.classList.remove("sidebar-hidden");
        sidebar.classList.add("show");
        toggleBtn.style.display = 'none';                           // Esconde o bot√£o de abrir
      });

      // Fecha a sidebar ao clicar no '√ó'
      closeBtn.addEventListener("click", () => {
        sidebar.classList.remove("show");
        sidebar.classList.add("sidebar-hidden");
        toggleBtn.style.display = 'block';                          // Reexibe o bot√£o de abrir
      });
    });

    // ===== Busca textual em tempo real =====
    const searchInput = document.getElementById("searchInput");
    searchInput.addEventListener("input", debounce(() => {
      const query = searchInput.value.toLowerCase();               // Termo digitado pelo usu√°rio

      // Para cada livro, verifica se o t√≠tulo inclui o termo de busca
      document.querySelectorAll('.book').forEach(book => {
        const title = book.querySelector(".book-title")?.textContent.toLowerCase() || "";
        book.classList.toggle("hidden", !title.includes(query));   // Oculta ou mostra o livro
      });
    }, 200));

  </script>
</body>

</html>
