<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Estante Virtual</title>
  <style>
    /* ======================================================
   CARREGAR ESQUELETO
   ‚Äî Anima√ß√£o ‚Äúpulse‚Äù para estado de carregamento
   ‚Äî .skeleton: estilo base para elementos placeholder
   ‚Äî .book.skeleton: mant√©m propor√ß√£o e visibilidade do esqueleto
   ‚Äî .loading-text: Mensagem de carregamento
   ====================================================== */

    @keyframes pulse {
      0% {
        background: #ddd;
      }

      50% {
        background: #ccc;
      }

      100% {
        background: #ddd;
      }
    }

    .loading-text {
      font-size: 1.2rem;
      font-weight: bold;
      color: #6f4e37;
      /* marrom Florido Doces */
      text-align: center;
      margin-bottom: 16px;
      /* espa√ßo antes dos skeletons */
    }

    .skeleton {
      background: #ddd;
      animation: pulse 1.5s infinite;
      border-radius: 4px;
    }

    .book.skeleton {
      aspect-ratio: 5 / 7;
      /* mant√©m propor√ß√£o de capa de livro */
      opacity: 1 !important;
      /* garante visibilidade */
      transform: none !important;
    }


    /* ======================================================
   ESTRUTURA DA √ÅRVORE DE FILTROS
   ‚Äî .tree: container principal de filtros
   ‚Äî .tree-toggle: alvos clic√°veis para expandir/contrair
   ‚Äî .toggle-icon: √≠cone de seta alinhado √† direita
   ====================================================== */

    .tree {
      display: block;
    }

    .tree>ul {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: none;
      overflow: visible;
    }

    .tree ul ul {
      padding-left: 10px;
      /* recuo para sublistas */
      max-height: 0;
      /* oculto por padr√£o */
      overflow: hidden;
      transition: max-height 0.4s ease-out;
    }

    .tree li {
      position: relative;
    }

    .tree-toggle {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-toggle.active-filter {
      background-color: rgba(255, 255, 255, 0.1);
      outline: 2px solid #6f4e37;
      /* destaque de filtro ativo */
    }

    .tree li.open>ul {
      max-height: 1000px;
      /* expande lista */
      transition: max-height 0.4s ease-in;
    }

    .toggle-icon {
      font-weight: bold;
      width: 1em;
      text-align: center;
      cursor: pointer;
      margin-left: auto;
      /* empurra para o fim */
      margin-right: 0;
    }


    /* ======================================================
   LAYOUT & SIDEBAR
   ‚Äî body: layout flex com sidebar fixa
   ‚Äî .sidebar: painel lateral de filtros fora da tela
   ‚Äî .sidebar.show / .sidebar-hidden: mostra/esconde
   ‚Äî .sidebar-header & .close-btn: cabe√ßalho da sidebar
   ‚Äî .main / .main.shifted: √°rea principal e estado deslocado
   ====================================================== */

    body {
      margin: 0;
      font-family: 'Georgia', serif;
      background: #f4efe9;
      display: flex;
      /* sidebar + conte√∫do */
    }

    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 260px;
      max-height: 100vh;
      background-color: rgba(62, 47, 28, 0.9);
      color: #fff;
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.4);
      padding: 20px;
      z-index: 1500;
      overflow-y: auto;
      transform: translateX(-100%);
      /* escondida √† esquerda */
      transition: transform 0.3s ease-in-out;
    }

    .sidebar.show {
      transform: translateX(0);
      /* mostra sidebar */
    }

    .sidebar.sidebar-hidden {
      transform: translateX(-100%);
      /* mant√©m escondida */
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .close-btn {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .main {
      flex: 1;
      padding: 30px;
      transition: margin 0.3s ease;
    }

    .main.shifted {
      margin-left: 260px;
      /* desloca ao abrir sidebar */
    }


    /* ======================================================
   BUSCA
   ‚Äî .search-container: wrapper flex
   ‚Äî #searchInput: input alinhado √† direita
   ====================================================== */

    .search-container {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 20px;
    }

    #searchInput {
      width: 200px;
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 6px;
      margin-left: auto;
      /* empurra para a direita */
    }


    /* ======================================================
   ESTANTE
   ‚Äî .shelf: container flex para livros
   ‚Äî .book: cart√£o individual com transi√ß√µes
   ‚Äî .book.showing: estado vis√≠vel
   ‚Äî Breakpoints para celulares
   ====================================================== */

    .shelf {
      display: flex;
      flex-wrap: wrap;
      gap: 25px;
      justify-content: center;
    }

    .book {
      width: calc(10% - 25px);
      min-width: 100px;
      text-align: center;
      font-size: 14px;
      color: #333;
      opacity: 0;
      /* oculto at√© aparecer */
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
    }

    .book.showing {
      opacity: 1;
      transform: none;
    }

    @media (max-width: 600px) {
      .book {
        width: calc(25% - 25px);
      }

      .shelf {
        gap: 16px;
      }
    }

    @media (max-width: 400px) {
      .book {
        width: calc(50% - 25px);
      }
    }


    /* ======================================================
   FLIP CARD
   ‚Äî .flip-card: cont√™iner com perspectiva 3D
   ‚Äî .flip-inner: contexto 3D e rota√ß√£o
   ‚Äî .flip-front / .flip-back: faces escondidas
   ‚Äî .hidden: oculta itens filtrados
   ‚Äî .no-cover: fallback quando a capa n√£o carregar
   ====================================================== */

    .flip-card {
      width: 100%;
      aspect-ratio: 5 / 7;
      perspective: 1000px;
    }

    .hidden {
      display: none !important;
    }

    .flip-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    @media (hover: hover) {
      .flip-card:hover .flip-inner {
        transform: rotateY(180deg);
        /* rota√ß√£o ao passar o mouse */
      }
    }

    .flip-card.flipped .flip-inner {
      transform: rotateY(180deg);
      /* rota√ß√£o por classe .flipped */
    }

    .flip-front,
    .flip-back {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 4px;
      backface-visibility: hidden;
      box-shadow: 3px 6px 10px rgba(0, 0, 0, 0.4);
    }

    .flip-front {
      overflow: hidden;
    }

    .flip-front img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .flip-back {
      background: #fff;
      color: #333;
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 8px;
      gap: 8px;
      text-align: center;
    }

    .book-title {
      font-size: 12px;
      font-weight: bold;
    }

    .read-button {
      font-size: 12px;
      padding: 4px 8px;
      background-color: #6f4e37;
      color: #fff;
      border: none;
      border-radius: 4px;
      text-decoration: none;
    }


    .no-cover {
      /* Flex vertical, permitindo m√∫ltiplas linhas de texto */
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
      align-items: center !important;
      width: 100%;
      height: 100%;
      background: #d9cfc3 !important;
      padding: 12px !important;
      box-sizing: border-box !important;
      text-align: center !important;
    }


    /* ======================================================
   UTILIT√ÅRIO & BOT√ÉO DE TOGGLE
   ‚Äî .toggle-button: bot√£o fixo para abrir filtros
   ====================================================== */

    .toggle-button {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: #6f4e37;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 2000;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <!-- Painel lateral de filtros, inicialmente oculto -->
  <div class="sidebar sidebar-hidden" id="sidebar">
    <!-- Cabe√ßalho da sidebar com t√≠tulo e bot√£o de fechar -->
    <div class="sidebar-header">
      <h2>üìö Filtros</h2> <!-- T√≠tulo da se√ß√£o de filtros -->
      <button id="closeSidebar" class="close-btn">√ó</button> <!-- Bot√£o para fechar a sidebar -->
    </div>
    <!-- Controles de expans√£o -->
    <div style="margin-bottom: 1rem; display: flex; gap: 8px;">
      <button id="expandAllBtn" class="read-button">Expandir tudo</button>
      <button id="collapseAllBtn" class="read-button">Recolher tudo</button>
    </div>
    <!-- Container da √°rvore de filtros (itens din√¢micos inseridos via JavaScript) -->
    <div class="tree" id="filterTree"></div>
  </div>

  <!-- Bot√£o fixo para abrir/fechar a sidebar de filtros -->
  <button id="toggleSidebar" class="toggle-button">üìÅ Filtros</button>

  <!-- √Årea principal de conte√∫do -->
  <div class="main">
    <!-- Wrapper flex para o campo de busca -->
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Buscar livro por nome‚Ä¶">
      <!-- Input para digitar o termo de busca -->
    </div>

    <!-- Container flex√≠vel que exibir√° as capas dos livros -->
    <div class="shelf" id="shelf"></div>
  </div>


  <script>
    // ===== Fun√ß√£o debounce =====
    // Atrasar a execu√ß√£o da fun√ß√£o fn at√© que o usu√°rio pare de disparar eventos por 'delay' ms
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);                     // Limpa qualquer timeout pendente
        timeout = setTimeout(() => fn.apply(this, args), delay);  // Agenda nova chamada
      };
    }

    // ===== Gera URL de dados para capa =====
    // Cria dinamicamente uma imagem de capa (PNG) usando canvas e retorna como DataURL

    // * Gera uma capa com t√≠tulo em m√∫ltiplas linhas, centralizado
    // * @param {string} title ‚Äî texto do t√≠tulo
    // * @param {number} width ‚Äî largura do canvas
    // * @param {number} height ‚Äî altura do canvas
    // * @returns {string} DataURL da imagem PNG

    function generateCoverDataUrl(title, width = 400, height = 600) {
      // Cria elemento canvas e define largura/altura
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");

      // Cria gradiente vertical de cor para fundo da capa
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, "#6f4e37");
      grad.addColorStop(1, "#d9cfc3");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);            // Preenche fundo

      // Configura estilo de texto para o t√≠tulo
      let fontSize = 48; // tamanho base
      ctx.font = `${fontSize}px serif`;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const maxTextWidth = width - 40;    // margem de 20px em cada lado
      const words = title.split(/\s+/);
      const lines = [];
      let currentLine = words[0];

      // Quebra em palavras que caibam no maxTextWidth
      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const testLine = `${currentLine} ${word}`;
        const { width: w } = ctx.measureText(testLine);
        if (w <= maxTextWidth) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      lines.push(currentLine);

      // Centraliza o bloco de texto verticalmente
      const lineHeight = fontSize * 1.2;
      const textBlockHeight = lines.length * lineHeight;
      let y = (height - textBlockHeight) / 2 + lineHeight / 2;

      // Desenha cada linha
      lines.forEach(line => {
        ctx.fillText(line, width / 2, y);
        y += lineHeight;
      });

      // Retorna DataURL em PNG
      return canvas.toDataURL("image/png");
    }

    // ===== Configura√ß√µes do Google Drive =====
    const folderId = "10A__4JOje3uuOc4-ywuwikswsgPiQf4R";  // ID da pasta de capas
    const apiKey = "AIzaSyCSfROD8xDz5GvmvcRIt5X1FqIWk2Yb7xc";     // Chave de API
    const capaFolderName = "capas";                              // Nome da subpasta de capas
    let capasDrive = {};                                          // Cache de metadados das capas

    // ===== Remove extens√£o de arquivo =====
    function stripExtension(name) {
      return name.replace(/\.[^/.]+$/, "");  // Remove tudo ap√≥s o √∫ltimo ponto
    }

    // ===== Constr√≥i objeto de √°rvore a partir de paths =====
    function buildTree(paths) {
      const tree = {};
      paths.forEach(path => {
        const parts = path.split("/").filter(Boolean);  // Divide por '/' e remove vazios
        let current = tree;
        parts.forEach(part => {
          if (!current[part]) current[part] = {};        // Cria n√≥ se n√£o existir
          current = current[part];                       // Desce um n√≠vel
        });
      });
      return tree;
    }

    // ===== Cria elementos HTML para √°rvore de filtros =====
    // Fun√ß√£o que cria a √°rvore de filtros com sele√ß√£o m√∫ltipla via checkboxes
    function createTreeElement(tree, parentPath = "") {
      const ul = document.createElement("ul");

      Object.keys(tree)
        .sort((a, b) => a.localeCompare(b, 'pt-BR'))
        .forEach(key => {
          const li = document.createElement("li");
          const fullPath = parentPath ? `${parentPath}/${key}` : key;
          const hasChildren = Object.keys(tree[key]).length > 0;

          // 1) Checkbox: marca/desmarca sem expandir n√≥s
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.dataset.path = fullPath;
          checkbox.addEventListener("click", e => e.stopPropagation());
          checkbox.addEventListener("change", () => filterBooksMulti());

          // 2) Texto: ao clicar expande/contrai este n√≥
          const textSpan = document.createElement("span");
          textSpan.className = "tree-toggle";
          textSpan.textContent = key;
          textSpan.style.cursor = "pointer";
          textSpan.style.marginLeft = "6px";
          textSpan.addEventListener("click", e => {
            if (!hasChildren) return;   // sem filhos, n√£o expande
            e.stopPropagation();
            li.classList.toggle("open");
            // atualiza √≠cone
            toggleIcon.textContent = li.classList.contains("open") ? "‚Äì" : "+";
          });

          // 3) Monta o header com checkbox e texto
          const header = document.createElement("div");
          header.style.display = "flex";
          header.style.alignItems = "center";
          header.append(checkbox, textSpan);

          // 4) Se houver filhos, cria e anexa o √≠cone; sen√£o, n√£o cria
          let toggleIcon;
          if (hasChildren) {
            toggleIcon = document.createElement("span");
            toggleIcon.className = "toggle-icon";
            toggleIcon.textContent = "+";  // inicialmente fechado
            toggleIcon.style.marginLeft = "auto";
            // clique no √≠cone tamb√©m expande/contrai
            toggleIcon.addEventListener("click", e => {
              e.stopPropagation();
              li.classList.toggle("open");
              toggleIcon.textContent = li.classList.contains("open") ? "‚Äì" : "+";
            });
            header.append(toggleIcon);
          }

          li.appendChild(header);

          // 5) Se tiver filhos, processa recursivamente
          if (hasChildren) {
            const subUl = createTreeElement(tree[key], fullPath);
            li.appendChild(subUl);
          }

          ul.appendChild(li);
        });

      return ul;
    }

    // Fun√ß√£o de filtro que exibe livros que correspondem a qualquer checkbox marcado
    function filterBooksMulti() {
      // Obt√©m todos os paths selecionados (lowercase)
      const selected = Array.from(
        document.querySelectorAll('.tree input[type="checkbox"]:checked')
      ).map(cb => cb.dataset.path.toLowerCase());

      document.querySelectorAll('.book[data-path]').forEach(book => {
        const bookPath = book.dataset.path.toLowerCase();

        if (selected.length === 0) {
          // sem filtros: mostra todos
          book.classList.remove("hidden");
        } else {
          // exibe se corresponder a qualquer categoria marcada
          const matches = selected.some(path =>
            bookPath === path || bookPath.startsWith(path + "/")
          );
          book.classList.toggle("hidden", !matches);
        }
      });
    }

    // Expande todos os n√≥s da √°rvore de filtros
    function expandAll() {
      document.querySelectorAll('.tree li').forEach(li => {
        const icon = li.querySelector('.toggle-icon');
        if (icon) {
          li.classList.add("open");
          icon.textContent = "‚Äì";
        }
      });
    }

    // Recolhe todos os n√≥s da √°rvore de filtros
    function collapseAll() {
      // 1) Seleciona o <li> raiz (o primeiro item dentro de .tree > ul)
      const rootLi = document.querySelector('.tree > ul > li');

      // 2) Para cada <li> que estiver aberto...
      document.querySelectorAll('.tree li.open').forEach(li => {
        // 3) ...se n√£o for o rootLi, fecha-o
        if (li !== rootLi) {
          li.classList.remove('open');
          const icon = li.querySelector('.toggle-icon');
          // 4) Atualiza o √≠cone para '+'
          if (icon) icon.textContent = '+';
        }
      });
    }


    // ===== Exibe skeletons enquanto os dados carregam =====
    function showSkeletons(count = 8) {
      const shelf = document.getElementById('shelf');

      // 1) Remove mensagem de carregamento anterior, se existir
      const oldMsg = document.querySelector('.loading-text');
      if (oldMsg) oldMsg.remove();

      // 2) Cria a mensagem de carregamento
      const loadingMsg = document.createElement('div');
      loadingMsg.className = 'loading-text';
      loadingMsg.textContent = 'Aguarde um pouco...';
      // Insere ANTES da estante, dentro do mesmo container (.main)
      shelf.parentNode.insertBefore(loadingMsg, shelf);

      // 3) Limpa qualquer conte√∫do anterior da estante
      shelf.innerHTML = '';

      // 4) Gera os skeletons dentro da estante
      for (let i = 0; i < count; i++) {
        const sk = document.createElement('div');
        sk.className = 'book skeleton';  // aplica propor√ß√£o e anima√ß√£o
        shelf.appendChild(sk);
      }
    }



    // ===== Busca ID de pasta pelo nome (Google Drive) =====
    async function getFolderIdByName(parentId, folderName) {
      const url =
        `https://www.googleapis.com/drive/v3/files?` +
        `q='${parentId}'+in+parents+and+trashed=false+and+mimeType='application/vnd.google-apps.folder'` +
        `&key=${apiKey}&fields=files(id,name)`;
      const res = await fetch(url);
      const data = await res.json();

      // Encontra a pasta que bate com o nome (case-insensitive)
      const folder = data.files.find(f => f.name.toLowerCase() === folderName.toLowerCase());
      return folder ? folder.id : null;
    }

    // ===== Lista recursivamente todas as capas dentro de uma pasta =====
    async function listCapasRecursively(parentId) {
      const url =
        `https://www.googleapis.com/drive/v3/files?` +
        `q='${parentId}'+in+parents+and+trashed=false` +
        `&key=${apiKey}&fields=files(id,name,mimeType)`;
      const res = await fetch(url);
      const data = await res.json();
      let result = {};

      for (const file of data.files) {
        if (file.mimeType === "application/vnd.google-apps.folder") {
          // Se for pasta, chama recursivamente
          const subResults = await listCapasRecursively(file.id);
          Object.assign(result, subResults);
        } else {
          // Adiciona URL da imagem da capa no resultado
          const name = stripExtension(file.name).toLowerCase();
          result[name] = `https://lh3.googleusercontent.com/d/${file.id}=w400-h600`;
        }
      }
      return result;
    }

    // ===== Lista recursivamente todos os arquivos de texto =====
    async function listFilesRecursively(parentId, path = "") {
      const url =
        `https://www.googleapis.com/drive/v3/files` +
        `?q='${parentId}'+in+parents+and+trashed=false` +
        `&key=${apiKey}` +
        `&fields=files(id,name,mimeType,webViewLink,thumbnailLink)`;
      const res = await fetch(url);
      const data = await res.json();
      let results = [];

      for (const file of data.files || []) {
        if (file.mimeType === "application/vnd.google-apps.folder") {
          // Ignora subpasta de capas e percorre outras pastas
          if (file.name.toLowerCase() === capaFolderName) continue;
          const sub = await listFilesRecursively(file.id, path + file.name + "/");
          results = results.concat(sub);
        } else {
          // Anexa caminho relativo e adiciona √† lista
          file.path = path;
          results.push(file);
        }
      }
      return results;
    }

    // ===== Renderiza os livros na estante =====
    async function renderBooks() {
      const shelf = document.getElementById('shelf');       // Container dos cards
      const treeRoot = document.getElementById('filterTree');  // Container da √°rvore de filtros

      // 1) Exibe skeletons e mensagem de carregamento
      showSkeletons();
      // Limpa √°rvore antiga
      treeRoot.innerHTML = '';

      try {
        // ===== 1) Carregamento e cache =====
        let files;
        const cache = sessionStorage.getItem('estanteCache');
        if (cache) {
          const parsed = JSON.parse(cache);
          const quatroHoras = 4 * 60 * 60 * 1000;
          const expirado = Date.now() - parsed.timestamp > quatroHoras;
          if (!expirado) {
            // Usa cache v√°lido
            files = parsed.files.sort((a, b) =>
              a.name.localeCompare(b.name, 'pt-BR', { sensitivity: 'base' })
            );
            capasDrive = parsed.capas;
          } else {
            sessionStorage.removeItem('estanteCache');
          }
        }

        if (!files) {
          // 1.1) Busca ID da pasta de capas
          const capaFolderId = await getFolderIdByName(folderId, capaFolderName);
          if (capaFolderId) {
            capasDrive = await listCapasRecursively(capaFolderId);
          }
          // 1.2) Lista arquivos de texto
          files = await listFilesRecursively(folderId);
          files.sort((a, b) =>
            a.name.localeCompare(b.name, 'pt-BR', { sensitivity: 'base' })
          );
          // 1.3) Armazena no cache
          sessionStorage.setItem(
            'estanteCache',
            JSON.stringify({ files, capas: capasDrive, timestamp: Date.now() })
          );
        }

        // ===== Remover mensagem de carregamento (fora da <div id="shelf">) =====
        const loadingMsg = document.querySelector('.loading-text');
        if (loadingMsg) loadingMsg.remove();

        // ===== 2) Cria√ß√£o dos cards =====
        shelf.innerHTML = '';  // Limpa skeletons e cards antigos
        const allPaths = [];

        for (const file of files) {
          const name = stripExtension(file.name);
          const nameNorm = name.toLowerCase();
          const path = file.path.replace(/\/$/, '');
          allPaths.push(path);

          // Escolhe URL de capa
          const manualCover = capasDrive[nameNorm];
          const thumbCover = file.thumbnailLink;
          const coverUrl = manualCover || thumbCover || generateCoverDataUrl(name);

          // Monta card flip
          const bookDiv = document.createElement('div');
          bookDiv.className = 'book';
          bookDiv.dataset.path = path;

          const flipCard = document.createElement('div');
          flipCard.className = 'flip-card';
          const flipInner = document.createElement('div');
          flipInner.className = 'flip-inner';

          // Face frontal (capa)
          const front = document.createElement('div');
          front.className = 'flip-front';

          const img = document.createElement('img');
          img.loading = 'lazy';
          img.src = coverUrl;
          img.alt = name;

          // Se falhar ao carregar, limpa e injeta o fallback
          img.onerror = () => {
            img.onerror = null;  // s√≥ uma tentativa
            // gera capa com texto
            img.src = generateCoverDataUrl(name, 400, 600);
          };

          // Se tudo der certo, apenas adiciona a imagem
          front.appendChild(img);

          // Face traseira (t√≠tulo + bot√£o)
          const back = document.createElement('div');
          back.className = 'flip-back';
          const bookTitle = document.createElement('div');
          bookTitle.className = 'book-title';
          bookTitle.textContent = name;
          const readButton = document.createElement('a');
          readButton.className = 'read-button';
          readButton.href = file.webViewLink;
          readButton.target = '_blank';
          readButton.textContent = 'Ler';
          back.append(bookTitle, readButton);

          flipInner.append(front, back);
          flipCard.appendChild(flipInner);
          bookDiv.appendChild(flipCard);
          shelf.appendChild(bookDiv);

          // Anima√ß√£o de entrada
          requestAnimationFrame(() => bookDiv.classList.add('showing'));
        }

        // ===== 3) Monta √°rvore de filtros =====
        const treeData = buildTree(allPaths);
        const treeStructure = createTreeElement(treeData);
        const wrapperUl = document.createElement('ul');
        const wrapperLi = document.createElement('li');
        wrapperLi.classList.add('open');
        wrapperLi.appendChild(treeStructure);
        wrapperUl.appendChild(wrapperLi);
        treeRoot.appendChild(wrapperUl);

        // ===== 4) Aplica filtro inicial (sem checkbox marcado) =====
        filterBooksMulti();

      } catch (err) {
        console.error("Erro ao carregar estante:", err);
        // Em caso de erro, remove a mensagem de carregamento e exibe aviso
        const loadingMsg = document.querySelector('.loading-text');
        if (loadingMsg) loadingMsg.remove();
        shelf.innerHTML = "<p>Erro ao carregar arquivos.</p>";
      }
    }

    // ===== Intera√ß√µes ap√≥s carregamento da p√°gina =====
    document.addEventListener("DOMContentLoaded", () => {
      renderBooks('Livros');                          // Carrega a estante quando o DOM estiver pronto

      const shelf = document.getElementById('shelf');
      const toggleBtn = document.getElementById("toggleSidebar");   // Bot√£o para abrir a sidebar
      const sidebar = document.getElementById("sidebar");         // Painel lateral de filtros
      const closeBtn = document.getElementById("closeSidebar");    // Bot√£o '√ó' para fechar a sidebar
      const filterTree = document.getElementById("filterTree");      // Elemento raiz da √°rvore de filtros

      // associa os bot√µes de Expandir / Recolher
      document.getElementById("expandAllBtn").addEventListener("click", expandAll);
      document.getElementById("collapseAllBtn").addEventListener("click", collapseAll);

      // ‚Äî‚Äî‚Äî Flip √∫nico por vez em mobile ‚Äî‚Äî‚Äî
      shelf.addEventListener('click', e => {
        const card = e.target.closest('.flip-card');
        if (!card) return;                         // s√≥ continua em cima de .flip-card
        if (e.target.closest('.read-button')) return; // ignora clique no ‚ÄúLer‚Äù

        // em telas ‚â§600px, desvira todos os outros antes de virar este
        if (window.innerWidth <= 600) {
          document.querySelectorAll('.flip-card.flipped')
            .forEach(c => { if (c !== card) c.classList.remove('flipped'); });
        }

        // executa o flip neste card
        card.classList.toggle('flipped');
      });

      // ‚Äî‚Äî‚Äî Fecha todos os flips ao clicar fora de qualquer card ‚Äî‚Äî‚Äî
      document.addEventListener('click', e => {
        if (e.target.closest('.flip-card') || e.target.closest('.read-button')) return;
        document.querySelectorAll('.flip-card.flipped')
          .forEach(c => c.classList.remove('flipped'));
      });

      // Fecha a sidebar ao clicar fora dela ou do bot√£o de toggle
      document.addEventListener("click", (event) => {
        const clickDentro = sidebar.contains(event.target);          // Clique dentro da sidebar?
        const clickToggle = toggleBtn.contains(event.target);        // Clique no bot√£o de abrir?

        if (!clickDentro && !clickToggle && sidebar.classList.contains("show")) {
          // Remove a classe que exibe a sidebar
          sidebar.classList.remove("show");
          sidebar.classList.add("sidebar-hidden");
          toggleBtn.style.display = "block";                        // Reexibe o bot√£o de abrir

          // Mant√©m apenas o n√≥ raiz da √°rvore sempre aberto
          const rootLi = filterTree.querySelector(":scope > ul > li");
          filterTree.querySelectorAll("li.open").forEach(li => {
            if (li !== rootLi) {
              li.classList.remove("open");                          // Fecha subn√≥s abertos
              const icon = li.querySelector(".toggle-icon");
              if (icon) icon.textContent = "+";                     // Restaura √≠cone de '+'
            }
          });
        }
      });

      // Abre a sidebar ao clicar no bot√£o de toggle
      toggleBtn.addEventListener("click", () => {
        sidebar.classList.remove("sidebar-hidden");
        sidebar.classList.add("show");
        toggleBtn.style.display = 'none';                           // Esconde o bot√£o de abrir
      });

      // Fecha a sidebar ao clicar no '√ó'
      closeBtn.addEventListener("click", () => {
        sidebar.classList.remove("show");
        sidebar.classList.add("sidebar-hidden");
        toggleBtn.style.display = 'block';                          // Reexibe o bot√£o de abrir
      });
    });

    // ===== Busca textual em tempo real =====
    const searchInput = document.getElementById("searchInput");
    searchInput.addEventListener("input", debounce(() => {
      const query = searchInput.value.toLowerCase();               // Termo digitado pelo usu√°rio

      // Para cada livro, verifica se o t√≠tulo inclui o termo de busca
      document.querySelectorAll('.book').forEach(book => {
        const title = book.querySelector(".book-title")?.textContent.toLowerCase() || "";
        book.classList.toggle("hidden", !title.includes(query));   // Oculta ou mostra o livro
      });
    }, 200));

  </script>
</body>

</html>
