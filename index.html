<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Estante Virtual</title>
  <style>
    /* ======================================================
   VARI√ÅVEIS DE TEMA
   ====================================================== */
    :root {
      /* cores claras (padr√£o) */
      --bg-body: #f4efe9;
      --text-main: #333;
      --bg-card: #fff;
      --bg-sidebar: #3e2f1c;
      --btn-bg: #6f4e37;
      --skeleton-bg: #ddd;
      --filter-text: #fff;
      --filter-active-bg: rgba(255, 255, 255, 0.1);
      --toggle-icon: #fff;
      --loading-text-color: var(--btn-bg);
      --input-bg: #fff;
      --input-text: #333;
      --input-placeholder: #666;
    }

    body.dark {
      /* cores escuras */
      --bg-body: #1e1e1e;
      --text-main: #ddd;
      --bg-card: #2a2a2a;
      --bg-sidebar: #141414;
      --btn-bg: #444;
      --skeleton-bg: #333;
      --filter-text: #ddd;
      --filter-active-bg: rgba(255, 255, 255, 0.1);
      --toggle-icon: #ddd;
      --loading-text-color: #ddd;
      --input-bg: #3a3a3a;
      --input-text: #eee;
      --input-placeholder: #aaa;
    }




    /* ======================================================
   CARREGAR ESQUELETO
   ‚Äî Anima√ß√£o ‚Äúpulse‚Äù para estado de carregamento
   ‚Äî .skeleton: estilo base para elementos placeholder
   ‚Äî .book.skeleton: mant√©m propor√ß√£o e visibilidade do esqueleto
   ‚Äî .loading-text: Mensagem de carregamento
   ====================================================== */

    .loading-text {
      font-size: 1.2rem;
      font-weight: bold;
      color: var(--loading-text-color);
      text-align: center;
      margin-bottom: 16px;
    }

    .skeleton {
      background: var(--skeleton-bg);
      animation: pulse 1.5s infinite;
      border-radius: 4px;
    }

    .book.skeleton {
      aspect-ratio: 5 / 7;
      opacity: 1 !important;
      transform: none !important;
    }

    /* ======================================================
   ESTRUTURA DA √ÅRVORE DE FILTROS
   ‚Äî .tree: container principal de filtros
   ‚Äî .tree-toggle: alvos clic√°veis para expandir/contrair
   ‚Äî .toggle-icon: √≠cone de seta alinhado √† direita
   ====================================================== */

    .tree {
      display: block;
    }

    .tree>ul {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: none;
      overflow: visible;
    }

    .tree ul ul {
      padding-left: 10px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease-out;
    }

    .tree li {
      position: relative;
    }

    .tree-toggle {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--filter-text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-toggle.active-filter {
      background-color: var(--filter-active-bg);
      outline: 2px solid var(--btn-bg);
    }

    .tree li.open>ul {
      max-height: 1000px;
      transition: max-height 0.4s ease-in;
    }

    .toggle-icon {
      font-weight: bold;
      width: 1em;
      text-align: center;
      cursor: pointer;
      margin-left: auto;
      color: var(--toggle-icon);
    }

    /* ======================================================
   LAYOUT & SIDEBAR
   ‚Äî body: layout flex com sidebar fixa
   ‚Äî .sidebar: painel lateral de filtros fora da tela
   ‚Äî #filterTree: espa√ßamento no final da arvore com o inferior da tela
   ‚Äî .sidebar.show / .sidebar-hidden: mostra/esconde
   ‚Äî .sidebar-header & .close-btn: cabe√ßalho da sidebar
   ‚Äî .main / .main.shifted: √°rea principal e estado deslocado
   ====================================================== */

    body {
      margin: 0;
      font-family: 'Georgia', serif;
      background: var(--bg-body);
      color: var(--text-main);
      display: flex;
    }

    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      width: 260px;
      height: 100vh;
      background-color: var(--bg-sidebar);
      color: var(--filter-text);
      box-shadow: 4px 0 12px rgba(0, 0, 0, 1);
      padding: 20px;
      z-index: 1500;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.3s ease-in-out;
    }

    #filterTree {
      padding-bottom: 60px;
      /* espa√ßo extra ap√≥s o √∫ltimo <li> */
    }


    .sidebar.show {
      transform: translateX(0);
    }

    .sidebar.sidebar-hidden {
      transform: translateX(-100%);
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .close-btn {
      background: none;
      border: none;
      color: var(--filter-text);
      font-size: 1.5rem;
      cursor: pointer;
    }

    .main {
      flex: 1;
      padding: 30px;
      transition: margin 0.3s ease;
    }

    .main.shifted {
      margin-left: 260px;
    }


    /* ======================================================
   BUSCA
   ‚Äî .search-container: wrapper flex
   ‚Äî #searchInput: input alinhado √† direita
   ====================================================== */

    .search-container {
      display: flex;
      justify-content: flex-end;
      margin-bottom: 20px;
    }

    #searchInput {
      width: 200px;
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 6px;
      margin-left: auto;
      background-color: var(--input-bg);
      color: var(--input-text);
      border: 1px solid var(--btn-bg);
    }

    /* placeholder do input */
    #searchInput::placeholder {
      color: var(--input-placeholder);
    }


    /* ======================================================
   ESTANTE
   ‚Äî .shelf: container flex para livros
   ‚Äî .book: cart√£o individual com transi√ß√µes
   ‚Äî .book.showing: estado vis√≠vel
   ‚Äî Breakpoints para celulares
   ====================================================== */

    .shelf {
      display: flex;
      flex-wrap: wrap;
      gap: 25px;
      justify-content: center;
    }

    .book {
      width: calc(15% - 25px);
      min-width: 100px;
      text-align: center;
      font-size: 14px;
      color: var(--text-main);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s, transform 0.3s;
    }

    .book.showing {
      opacity: 1;
      transform: none;
    }

    @media (max-width: 600px) {
      .book {
        width: calc(25% - 25px);
      }

      .shelf {
        gap: 16px;
      }
    }

    @media (max-width: 400px) {
      .book {
        width: calc(50% - 25px);
      }
    }

    /* ======================================================
   FLIP CARD
   ‚Äî .flip-card: cont√™iner com perspectiva 3D
   ‚Äî .flip-inner: contexto 3D e rota√ß√£o
   ‚Äî .flip-front / .flip-back: faces escondidas
   ‚Äî .hidden: oculta itens filtrados
   ‚Äî .no-cover: fallback quando a capa n√£o carregar
   ====================================================== */

    .flip-card {
      width: 100%;
      aspect-ratio: 5 / 7;
      perspective: 1000px;
    }

    .hidden {
      display: none !important;
    }

    .flip-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    @media (hover: hover) {
      .flip-card:hover .flip-inner {
        transform: rotateY(180deg);
      }
    }

    .flip-card.flipped .flip-inner {
      transform: rotateY(180deg);
    }

    .flip-front,
    .flip-back {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 4px;
      backface-visibility: hidden;
      box-shadow: 3px 6px 10px rgba(0, 0, 0, 0.4);
    }

    .flip-front {
      overflow: hidden;
    }

    .flip-front img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .flip-back {
      background: var(--bg-card);
      color: var(--text-main);
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 8px;
      gap: 8px;
      text-align: center;
    }

    .book-title {
      font-size: 12px;
      font-weight: bold;
    }

    .read-button {
      font-size: 12px;
      padding: 4px 8px;
      background-color: var(--btn-bg);
      color: #fff;
      border: none;
      border-radius: 4px;
      text-decoration: none;
    }


    /* ======================================================
   NO-COVER FALLBACK
   ====================================================== */

    .no-cover {
      /* Flex vertical, permitindo m√∫ltiplas linhas de texto */
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
      align-items: center !important;
      width: 100%;
      height: 100%;
      background: #d9cfc3 !important;
      padding: 12px !important;
      box-sizing: border-box !important;
      text-align: center !important;
    }

    /* ======================================================
   UTILIT√ÅRIO & BOT√ÉO DE TOGGLE
   ‚Äî .toggle-button: bot√£o fixo para abrir filtros
   ====================================================== */

    .toggle-button {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: var(--btn-bg);
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 2000;
      cursor: pointer;
    }

    #toggleTheme {
      position: fixed;
      top: auto;
      /* anula o top original */
      bottom: 20px;
      /* 20px acima da base da janela */
      right: 20px;
      /* 20px da borda direita */
      left: auto;
      /* anula o left original */
      z-index: 2000;
      /* garante que fique acima de tudo */
    }
  </style>
</head>

<body>
  <!-- Painel lateral de filtros, inicialmente oculto -->
  <div class="sidebar sidebar-hidden" id="sidebar">
    <!-- Cabe√ßalho da sidebar com t√≠tulo e bot√£o de fechar -->
    <div class="sidebar-header">
      <h2>üìö Filtros</h2> <!-- T√≠tulo da se√ß√£o de filtros -->
      <button id="closeSidebar" class="close-btn">√ó</button> <!-- Bot√£o para fechar a sidebar -->
    </div>
    <!-- Controles de expans√£o -->
    <div style="margin-bottom: 1rem; display: flex; gap: 8px;">
      <button id="expandAllBtn" class="read-button">Expandir tudo</button>
      <button id="collapseAllBtn" class="read-button">Recolher tudo</button>
    </div>
    <!-- Container da √°rvore de filtros (itens din√¢micos inseridos via JavaScript) -->
    <div class="tree" id="filterTree"></div>
  </div>

  <!-- Bot√£o fixo para abrir/fechar a sidebar de filtros -->
  <button id="toggleSidebar" class="toggle-button">üìÅ Filtros</button>
  <button id="toggleTheme" class="toggle-button">
    üåô
  </button>

  <!-- √Årea principal de conte√∫do -->
  <div class="main">
    <!-- Wrapper flex para o campo de busca -->
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Buscar livro por nome‚Ä¶">
      <!-- Input para digitar o termo de busca -->
    </div>

    <!-- Container flex√≠vel que exibir√° as capas dos livros -->
    <div class="shelf" id="shelf"></div>
  </div>


  <script>
    // ===== Fun√ß√£o debounce =====
    // Atrasar a execu√ß√£o da fun√ß√£o fn at√© que o usu√°rio pare de disparar eventos por 'delay' ms
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);                     // Limpa qualquer timeout pendente
        timeout = setTimeout(() => fn.apply(this, args), delay);  // Agenda nova chamada
      };
    }

    // ===== Gera URL de dados para capa =====
    // Cria dinamicamente uma imagem de capa (PNG) usando canvas e retorna como DataURL

    // * Gera uma capa com t√≠tulo em m√∫ltiplas linhas, centralizado
    // * @param {string} title ‚Äî texto do t√≠tulo
    // * @param {number} width ‚Äî largura do canvas
    // * @param {number} height ‚Äî altura do canvas
    // * @returns {string} DataURL da imagem PNG

    function generateCoverDataUrl(title, width = 400, height = 600) {
      // Cria elemento canvas e define largura/altura
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");

      // Cria gradiente vertical de cor para fundo da capa
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, "#6f4e37");
      grad.addColorStop(1, "#d9cfc3");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);            // Preenche fundo

      // Configura estilo de texto para o t√≠tulo
      let fontSize = 48; // tamanho base
      ctx.font = `${fontSize}px serif`;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const maxTextWidth = width - 40;    // margem de 20px em cada lado
      const words = title.split(/\s+/);
      const lines = [];
      let currentLine = words[0];

      // Quebra em palavras que caibam no maxTextWidth
      for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const testLine = `${currentLine} ${word}`;
        const { width: w } = ctx.measureText(testLine);
        if (w <= maxTextWidth) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      lines.push(currentLine);

      // Centraliza o bloco de texto verticalmente
      const lineHeight = fontSize * 1.2;
      const textBlockHeight = lines.length * lineHeight;
      let y = (height - textBlockHeight) / 2 + lineHeight / 2;

      // Desenha cada linha
      lines.forEach(line => {
        ctx.fillText(line, width / 2, y);
        y += lineHeight;
      });

      // Retorna DataURL em PNG
      return canvas.toDataURL("image/png");
    }

    // ===== Configura√ß√µes do Google Drive =====
    const folderId = "10A__4JOje3uuOc4-ywuwikswsgPiQf4R";  // ID da pasta de capas
    const apiKey = "AIzaSyCSfROD8xDz5GvmvcRIt5X1FqIWk2Yb7xc";     // Chave de API
    const capaFolderName = "capas";                              // Nome da subpasta de capas
    let capasDrive = {};                                          // Cache de metadados das capas

    // ===== Remove extens√£o de arquivo =====
    function stripExtension(name) {
      return name.replace(/\.[^/.]+$/, "");  // Remove tudo ap√≥s o √∫ltimo ponto
    }

    // ===== Constr√≥i objeto de √°rvore a partir de paths =====
    function buildTree(paths) {
      const tree = {};
      paths.forEach(path => {
        const parts = path.split("/").filter(Boolean);  // Divide por '/' e remove vazios
        let current = tree;
        parts.forEach(part => {
          if (!current[part]) current[part] = {};        // Cria n√≥ se n√£o existir
          current = current[part];                       // Desce um n√≠vel
        });
      });
      return tree;
    }

    // ===== Cria elementos HTML para √°rvore de filtros =====
    // Fun√ß√£o que cria a √°rvore de filtros com sele√ß√£o m√∫ltipla via checkboxes
    function createTreeElement(tree, parentPath = "") {
      const ul = document.createElement("ul");

      Object.keys(tree)
        .sort((a, b) => a.localeCompare(b, 'pt-BR'))
        .forEach(key => {
          const li = document.createElement("li");
          const fullPath = parentPath ? `${parentPath}/${key}` : key;
          const hasChildren = Object.keys(tree[key]).length > 0;

          // 1) Checkbox: marca/desmarca sem expandir n√≥s
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.dataset.path = fullPath;
          checkbox.addEventListener("click", e => e.stopPropagation());
          checkbox.addEventListener("change", () => filterBooksMulti());

          // 2) Texto: ao clicar expande/contrai este n√≥
          const textSpan = document.createElement("span");
          textSpan.className = "tree-toggle";
          textSpan.textContent = key;
          textSpan.style.cursor = "pointer";
          textSpan.style.marginLeft = "6px";
          textSpan.addEventListener("click", e => {
            if (!hasChildren) return;   // sem filhos, n√£o expande
            e.stopPropagation();
            li.classList.toggle("open");
            // atualiza √≠cone
            toggleIcon.textContent = li.classList.contains("open") ? "‚Äì" : "+";
          });

          // 3) Monta o header com checkbox e texto
          const header = document.createElement("div");
          header.style.display = "flex";
          header.style.alignItems = "center";
          header.append(checkbox, textSpan);

          // 4) Se houver filhos, cria e anexa o √≠cone; sen√£o, n√£o cria
          let toggleIcon;
          if (hasChildren) {
            toggleIcon = document.createElement("span");
            toggleIcon.className = "toggle-icon";
            toggleIcon.textContent = "+";  // inicialmente fechado
            toggleIcon.style.marginLeft = "auto";
            // clique no √≠cone tamb√©m expande/contrai
            toggleIcon.addEventListener("click", e => {
              e.stopPropagation();
              li.classList.toggle("open");
              toggleIcon.textContent = li.classList.contains("open") ? "‚Äì" : "+";
            });
            header.append(toggleIcon);
          }

          li.appendChild(header);

          // 5) Se tiver filhos, processa recursivamente
          if (hasChildren) {
            const subUl = createTreeElement(tree[key], fullPath);
            li.appendChild(subUl);
          }

          ul.appendChild(li);
        });

      return ul;
    }

    // Fun√ß√£o de filtro que exibe livros que correspondem a qualquer checkbox marcado
    function filterBooksMulti() {
      // Obt√©m todos os paths selecionados (lowercase)
      const selected = Array.from(
        document.querySelectorAll('.tree input[type="checkbox"]:checked')
      ).map(cb => cb.dataset.path.toLowerCase());

      document.querySelectorAll('.book[data-path]').forEach(book => {
        const bookPath = book.dataset.path.toLowerCase();

        if (selected.length === 0) {
          // sem filtros: mostra todos
          book.classList.remove("hidden");
        } else {
          // exibe se corresponder a qualquer categoria marcada
          const matches = selected.some(path =>
            bookPath === path || bookPath.startsWith(path + "/")
          );
          book.classList.toggle("hidden", !matches);
        }
      });
    }

    // Expande todos os n√≥s da √°rvore de filtros
    function expandAll() {
      document.querySelectorAll('.tree li').forEach(li => {
        const icon = li.querySelector('.toggle-icon');
        if (icon) {
          li.classList.add("open");
          icon.textContent = "‚Äì";
        }
      });
    }

    // Recolhe todos os n√≥s da √°rvore de filtros
    function collapseAll() {
      // 1) Seleciona o <li> raiz (o primeiro item dentro de .tree > ul)
      const rootLi = document.querySelector('.tree > ul > li');

      // 2) Para cada <li> que estiver aberto...
      document.querySelectorAll('.tree li.open').forEach(li => {
        // 3) ...se n√£o for o rootLi, fecha-o
        if (li !== rootLi) {
          li.classList.remove('open');
          const icon = li.querySelector('.toggle-icon');
          // 4) Atualiza o √≠cone para '+'
          if (icon) icon.textContent = '+';
        }
      });
    }


    // ===== Exibe skeletons enquanto os dados carregam =====
    function showSkeletons(count = 8) {
      const shelf = document.getElementById('shelf');

      // 1) Remove mensagem de carregamento anterior, se existir
      const oldMsg = document.querySelector('.loading-text');
      if (oldMsg) oldMsg.remove();

      // 2) Cria a mensagem de carregamento
      const loadingMsg = document.createElement('div');
      loadingMsg.className = 'loading-text';
      loadingMsg.textContent = 'Aguarde um pouco...';
      // Insere ANTES da estante, dentro do mesmo container (.main)
      shelf.parentNode.insertBefore(loadingMsg, shelf);

      // 3) Limpa qualquer conte√∫do anterior da estante
      shelf.innerHTML = '';

      // 4) Gera os skeletons dentro da estante
      for (let i = 0; i < count; i++) {
        const sk = document.createElement('div');
        sk.className = 'book skeleton';  // aplica propor√ß√£o e anima√ß√£o
        shelf.appendChild(sk);
      }
    }



    // ===== Busca ID de pasta pelo nome (Google Drive) =====
    async function getFolderIdByName(parentId, folderName) {
      const url =
        `https://www.googleapis.com/drive/v3/files?` +
        `q='${parentId}'+in+parents+and+trashed=false+and+mimeType='application/vnd.google-apps.folder'` +
        `&key=${apiKey}&fields=files(id,name)`;
      const res = await fetch(url);
      const data = await res.json();

      // Encontra a pasta que bate com o nome (case-insensitive)
      const folder = data.files.find(f => f.name.toLowerCase() === folderName.toLowerCase());
      return folder ? folder.id : null;
    }

    // ===== Lista recursivamente todas as capas dentro de uma pasta =====
    async function listCapasRecursively(parentId) {
      let result = {};
      let pageToken = null;

      do {
        const url =
          `https://www.googleapis.com/drive/v3/files?` +
          `q='${parentId}'+in+parents+and+trashed=false` +
          `&key=${apiKey}` +
          `&fields=nextPageToken,files(id,name,mimeType,thumbnailLink)` +
          `&pageSize=1000` +
          (pageToken ? `&pageToken=${pageToken}` : '');

        const res = await fetch(url);
        const data = await res.json();
        console.log('[listCapasRecursively] Fetched', data.files.length, 'files');

        for (const file of data.files) {
          if (file.mimeType === "application/vnd.google-apps.folder") {
            const sub = await listCapasRecursively(file.id);
            Object.assign(result, sub);
          } else {
            const name = stripExtension(file.name).toLowerCase();
            // usamos thumbnailLink direto, garantindo que seja um JPG/PNG v√°lido
            result[name] = file.thumbnailLink;
          }
        }

        pageToken = data.nextPageToken;
      } while (pageToken);

      console.log('[listCapasRecursively] Total de capas mapeadas:', Object.keys(result).length);
      return result;
    }



    // ===== Lista recursivamente todos os arquivos de texto =====
    async function listFilesRecursively(parentId, path = "") {
      const url =
        `https://www.googleapis.com/drive/v3/files` +
        `?q='${parentId}'+in+parents+and+trashed=false` +
        `&key=${apiKey}` +
        `&fields=files(id,name,mimeType,webViewLink,thumbnailLink)`;
      const res = await fetch(url);
      const data = await res.json();
      let results = [];

      for (const file of data.files || []) {
        if (file.mimeType === "application/vnd.google-apps.folder") {
          // Ignora subpasta de capas e percorre outras pastas
          if (file.name.toLowerCase() === capaFolderName) continue;
          const sub = await listFilesRecursively(file.id, path + file.name + "/");
          results = results.concat(sub);
        } else {
          // Anexa caminho relativo e adiciona √† lista
          file.path = path;
          results.push(file);
        }
      }
      return results;
    }

    // ‚Äî‚Äî‚Äî Fun√ß√£o auxiliar para "achatar" a √°rvore de filtros em uma lista de paths ‚Äî‚Äî‚Äî
    function flattenPaths(tree, parentPath = "") {
      let order = [];
      Object.keys(tree)
        .sort((a, b) => a.localeCompare(b, 'pt-BR'))
        .forEach(key => {
          const fullPath = parentPath ? `${parentPath}/${key}` : key;
          order.push(fullPath);
          order = order.concat(flattenPaths(tree[key], fullPath));
        });
      return order;
    }

    // ===== Renderiza os livros na estante =====
    async function renderBooks() {
      const shelf = document.getElementById('shelf');
      const treeRoot = document.getElementById('filterTree');

      // 1) exibe skeletons
      showSkeletons();
      treeRoot.innerHTML = '';  // limpa tree antiga

      try {
        // 2) carrega arquivos e capas (cache ou API)
        let files;
        const cache = sessionStorage.getItem('estanteCache');
        if (cache) {
          const parsed = JSON.parse(cache);
          const quatroHoras = 4 * 60 * 60 * 1000;
          if (Date.now() - parsed.timestamp <= quatroHoras) {
            files = parsed.files;
            capasDrive = parsed.capas;
          } else {
            sessionStorage.removeItem('estanteCache');
          }
        }
        if (!files) {
          const capaFolderId = await getFolderIdByName(folderId, capaFolderName);
          if (capaFolderId) capasDrive = await listCapasRecursively(capaFolderId);
          files = await listFilesRecursively(folderId);
          sessionStorage.setItem(
            'estanteCache',
            JSON.stringify({ files, capas: capasDrive, timestamp: Date.now() })
          );
        }

        // 3) remove loading
        document.querySelector('.loading-text')?.remove();

        // 4) monta √°rvore e obt√©m a ordem dos paths
        const allPaths = files.map(f => f.path.replace(/\/$/, ''));
        const treeData = buildTree(allPaths);
        const orderedPaths = flattenPaths(treeData);

        // 5) ordena files:
        //    a) pelo √≠ndice em orderedPaths (ordem dos filtros)
        //    b) se estiverem no mesmo filtro, alfabeticamente pelo nome
        files.sort((a, b) => {
          const pa = a.path.replace(/\/$/, '');
          const pb = b.path.replace(/\/$/, '');
          const idxA = orderedPaths.indexOf(pa);
          const idxB = orderedPaths.indexOf(pb);
          if (idxA !== idxB) return idxA - idxB;
          return a.name.localeCompare(b.name, 'pt-BR', { sensitivity: 'base' });
        });

        // 6) renderiza todos os cards no mesmo shelf
        shelf.innerHTML = '';
        files.forEach(file => {
          const name = stripExtension(file.name);
          const nameNorm = name.toLowerCase();
          const path = file.path.replace(/\/$/, '');
          const manualCover = capasDrive[nameNorm];
          const coverUrl = manualCover || generateCoverDataUrl(name);

          const bookDiv = document.createElement('div');
          bookDiv.className = 'book';
          bookDiv.dataset.path = path;

          const flipCard = document.createElement('div');
          flipCard.className = 'flip-card';
          const flipInner = document.createElement('div');
          flipInner.className = 'flip-inner';

          // frente
          const front = document.createElement('div');
          front.className = 'flip-front';
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.src = coverUrl;
          img.alt = name;
          img.onerror = () => img.src = generateCoverDataUrl(name, 400, 600);
          front.appendChild(img);

          // verso
          const back = document.createElement('div');
          back.className = 'flip-back';
          const title = document.createElement('div');
          title.className = 'book-title';
          title.textContent = name;
          const btn = document.createElement('a');
          btn.className = 'read-button';
          btn.href = file.webViewLink;
          btn.target = '_blank';
          btn.textContent = 'Ler';
          back.append(title, btn);

          flipInner.append(front, back);
          flipCard.appendChild(flipInner);
          bookDiv.appendChild(flipCard);
          shelf.appendChild(bookDiv);

          requestAnimationFrame(() => bookDiv.classList.add('showing'));
        });

        // 7) monta novamente a √°rvore de filtros
        const treeStructure = createTreeElement(treeData);
        const wrapperUl = document.createElement('ul');
        const wrapperLi = document.createElement('li');
        wrapperLi.classList.add('open');
        wrapperLi.appendChild(treeStructure);
        wrapperUl.appendChild(wrapperLi);
        treeRoot.appendChild(wrapperUl);

        // 8) aplica filtro inicial
        filterBooksMulti();

      } catch (err) {
        console.error("Erro ao carregar estante:", err);
        document.querySelector('.loading-text')?.remove();
        shelf.innerHTML = "<p>Erro ao carregar arquivos.</p>";
      }
    }


    // ===== Intera√ß√µes ap√≥s carregamento da p√°gina =====
    document.addEventListener("DOMContentLoaded", () => {
      renderBooks('Livros');                          // Carrega a estante quando o DOM estiver pronto

      const shelf = document.getElementById('shelf');
      const toggleBtn = document.getElementById("toggleSidebar");   // Bot√£o para abrir a sidebar
      const sidebar = document.getElementById("sidebar");         // Painel lateral de filtros
      const closeBtn = document.getElementById("closeSidebar");    // Bot√£o '√ó' para fechar a sidebar
      const filterTree = document.getElementById("filterTree");      // Elemento raiz da √°rvore de filtros

      // associa os bot√µes de Expandir / Recolher
      document.getElementById("expandAllBtn").addEventListener("click", expandAll);
      document.getElementById("collapseAllBtn").addEventListener("click", collapseAll);

      // ‚Äî‚Äî‚Äî Flip √∫nico por vez em mobile ‚Äî‚Äî‚Äî
      shelf.addEventListener('click', e => {
        const card = e.target.closest('.flip-card');
        if (!card) return;                         // s√≥ continua em cima de .flip-card
        if (e.target.closest('.read-button')) return; // ignora clique no ‚ÄúLer‚Äù

        // em telas ‚â§600px, desvira todos os outros antes de virar este
        if (window.innerWidth <= 600) {
          document.querySelectorAll('.flip-card.flipped')
            .forEach(c => { if (c !== card) c.classList.remove('flipped'); });
        }

        // executa o flip neste card
        card.classList.toggle('flipped');
      });

      // ‚Äî‚Äî‚Äî Fecha todos os flips ao clicar fora de qualquer card ‚Äî‚Äî‚Äî
      document.addEventListener('click', e => {
        if (e.target.closest('.flip-card') || e.target.closest('.read-button')) return;
        document.querySelectorAll('.flip-card.flipped')
          .forEach(c => c.classList.remove('flipped'));
      });

      // Fecha a sidebar ao clicar fora dela ou do bot√£o de toggle
      document.addEventListener("click", (event) => {
        const clickDentro = sidebar.contains(event.target);          // Clique dentro da sidebar?
        const clickToggle = toggleBtn.contains(event.target);        // Clique no bot√£o de abrir?

        if (!clickDentro && !clickToggle && sidebar.classList.contains("show")) {
          // Remove a classe que exibe a sidebar
          sidebar.classList.remove("show");
          sidebar.classList.add("sidebar-hidden");
          toggleBtn.style.display = "block";                        // Reexibe o bot√£o de abrir
        }
      });

      // Abre a sidebar ao clicar no bot√£o de toggle
      toggleBtn.addEventListener("click", () => {
        sidebar.classList.remove("sidebar-hidden");
        sidebar.classList.add("show");
        toggleBtn.style.display = 'none';                           // Esconde o bot√£o de abrir
      });

      // Fecha a sidebar ao clicar no '√ó'
      closeBtn.addEventListener("click", () => {
        sidebar.classList.remove("show");
        sidebar.classList.add("sidebar-hidden");
        toggleBtn.style.display = 'block';                          // Reexibe o bot√£o de abrir
      });
    });

    // ===== Busca textual em tempo real =====
    const searchInput = document.getElementById("searchInput");
    function removeAccents(str) {         // utilit√°rio pra remover acentos
      return str
        .normalize('NFD')                 // separa base + diacr√≠ticos
        .replace(/[\u0300-\u036f]/g, ''); // remove os diacr√≠ticos
    }
    searchInput.addEventListener("input", debounce(() => {
      const rawQuery = searchInput.value.toLowerCase(); // Termo digitado pelo usu√°rio
      const query = removeAccents(rawQuery); // remove acentuacao

      // Para cada livro, verifica se o t√≠tulo inclui o termo de busca
      document.querySelectorAll('.book').forEach(book => {
        const titleRaw = book.querySelector(".book-title")?.textContent.toLowerCase() || "";
        const title = removeAccents(titleRaw);
        book.classList.toggle("hidden", !title.includes(query)); // Oculta ou mostra o livro
      });
    }, 200));

    // ===== Modo Noturno =====
    const themeBtn = document.getElementById('toggleTheme');
    const current = localStorage.getItem('theme') || '';

    if (current === 'dark') {
      document.body.classList.add('dark');
      themeBtn.textContent = '‚òÄÔ∏è';
    }

    themeBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark');
      const isDark = document.body.classList.contains('dark');
      themeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
    });


  </script>
</body>

</html>
